# FastGO

FastGo 是一个快速完整的 Go 项目实例，从今天开始，我们将从零开始构建 FastGo 项目。

# 预知识：GO 项目结构



# 1. 使用 Cobra 包来构建项目

对于一个项目，我们经常需要使用命令行带参数的形式来启动程序，因此我们需要获取这些参数。
传统的方式，我们通常在 `main` 函数中依次读取这些参数，这就会使得你的 `main` 函数非常庞大，不易阅读。

```go
func main() {
    // 解析命令行参数
    opt1 := flag.String("opt1", "default_value", "Description of opt 1")
    opt2 := flag.String("opt2", 0, "Description of opt 2")
    flag.Parse()
    
    fmt.Println("opt1's value is: ", *opt1)
    fmt.Println("opt2's value is: ", *opt2)
    
    // 接下来执行主逻辑。。。
}
```
因此，我们可以使用社区提供的优秀框架来实现这个功能，比如 **spf13/cobra** 就是一个优秀的主函数启动框架。

# 2. 添加 viper 进行配置读取

配置文件几乎是每个服务都需要用到的功能。Go 项目开发中有很多种配置源解析的方式，比如命令行、环境变量、配置文件等等，推荐的方式还是使用配置文件进行，
比如 yaml 或者 yml。Go 社区也提供了很多优秀的配置源解析框架，其中比较热门的是 spf13/viper，和 cobra 师出同门。

要实现配置项的读取，关键的一点是在项目启动时便让程序能够知道并找到配置源在哪，这样子才能在后续的使用中读取编写的配置项，因此我们需要在
项目启动时做好相关的配置，并提前将对应的配置文件存储在想要的目录下。

# 3. 框架代码和业务代码分离

在 Go 项目的开发中，代码通常分为两种：
- 应用启动框架：如前面的内容，配置项、命令行
- 业务相关

为了提高整体的可维护性，可以将二者的代码进行物理区分，在目录级别上进行隔离，减少各自的变动对对方的影响。

尽管我们希望做到二者的分离，但是仍然会存在代码共用的情况，因此需要将相关的代码放在合适的目录中。

因此，项目的启动顺序发生了变更：
- 原始：主程序启动 -> 读取配置文件 -> 主程序根据配置文件进行业务的处理
- 变更后： 主程序启动 -> 读取配置文件，生成配置文件对象 -> 通过配置文件对象生成服务配置 -> 通过服务配置启动业务逻辑

变更后的程序逻辑结构更加清晰，维护也更加容易。

# 4. 实现版本号打印功能

为了方便排障，经常需要知道某个应用的版本信息，同时有时候也需要命令行通过 -v --version version 显示版本信息，这时候就需要给应用添加版本信息。

因此，我们需要一个地方用于保存版本信息，然后将版本信息注入到当前位置，并运行应用程序通过命令行显示对应版本信息。

# 5. 实现日志打印功能

日志打印不用说，能够方便我们在进行业务代码的处理时能够很好的知道进展情况以及错误发生的情况，一个好的日志是非常有必要的。

# 6. 基于 Gin 实现 HTTP 服务器

Go 项目开发场景最多的是构建一个 HTTP 应用，因此就需要我们对外提供相应的接口，供外部调用。

常见的实现方式有调用 Go 提供的 net 模块，但这样十分耗时，我们可以使用优秀的开源框架进行构建，比如 Gin。

# 7. 中间件

中间件是应用请求-响应处理循环中的一个特殊函数。它可以在请求到达业务逻辑之前修改/处理请求，或者是在响应返回客户端之前修改/处理响应。

中间件的本质作用是对请求或响应进行预处理、后处理或者监控。它允许在请求接受或者响应发送之前或之插入自定义逻辑，从而实现多种功能，包括
认证、授权、日志记录、性能监测、错误处理、请求验证、跨域支持、限流等。

Gin框架也支持中间件，它有三种使用方式：
- 全局中间件，会作用于所有路由；
- 路由组中间件，只对当前组内的路由产生作用；
- 单个路由中间件，只对当前 路由产生作用。

这里，我们将开发三种常见的中间件，从而来进行中间件的实战：
- NoCache：通过设置一些 Header，禁止客户端缓存 HTTP 的响应；
- Cors：用来设置 options 请求的返回头，然后退出中间键链，并结束请求（浏览器跨域设置）；
- RequestID：用来在每个 HTTP 请求的 context、response 中注入 x-request-id 键值对。

❕需要注意，中间件的使用需要先注册中间件，后注册路由，顺序很重要。若先注册路由，再注册中间件，则中间件没有效果。

# 8. 优雅关停

优雅关停服务器有很多好处，比如提高 API 成功率，减少脏数据出现的可能。

# 9. 实现统一的错误返回

为了方便客户端处理返回，排查错误，还需要实现统一的错误返回，其中包含两个方面：
1. 错误格式统一：方便客户端解析，并获取错误；
2. 自定义业务错误码：HTTP 的错误码有限且宽泛，并不能有效适合所有业务，因此需要构建自定义错误码，涵盖自己的程序。

# 10. 定义简洁架构层的 Store 结构

实现数据结构层

# 11. 定义简介架构层的 Biz 结构

# 12. 定义简洁架构的 Handler 层

# 13. 实现身份认证功能

应用安全是软件开发时必须要考虑和设计的核心点。不安全的应用会带来诸如数据泄漏，应用服务中断等严重问题。

在前后端分离的架构中，最常见的身份认证方式为基础认证与令牌认证相结合：
- 基础认证：通过用户名密码登陆系统
- 令牌认证：通过 Token 进行认证，请求访问后台服务。

基础认证主要用作初始登陆系统时使用。它会向后台传递用户名密码，判断数据库中是否存在当前用户，如果存在则能够访问当前系统的后续功能。

但后台怎么判断你是否能够访问后续的服务呢？他只有在第一次访问认证成功的时候才知道你能访问后续的功能，难道每次都要通过用户名密码进行认证吗？

显然不行。用户登陆流程其中涉及到很多的内容，效率不高，如果每次请求都采用这种方式那么显而易见的，这个系统会很卡（用户体验差）。因此一个理想的方式是使用一个
前后端都知道的东西，每次请求时传递这个东西，让后端知道你是我认证过的可以访问的人，呢不就行了么。

这个东西，就是令牌。

令牌通过后端颁布后，在第一次请求后带回。之后的每次请求，只要带上后端颁布的令牌，那么就可以畅快无阻的访问所有服务了。这个令牌我们可以理解为一个字符串，后台
判断字符串是否合法相较于判断用户名密码是否正确，要快的不止一星半点。

具体来说，在第一次请求后，后台会生成一个具有有效期的令牌，并存储在浏览器的 Cookies 中或者 LocalStorage 里。每次请求携带 Token，后台对当前 Token
进行鉴权，看是否合法，是否超时。由于会超时，后台可以提供一个刷新有效期的接口，定时请求刷新需要刷新的 Token。Token 有很多实现方式，业内常用的是 Json Web Token，简称 JWT。